import java.util.Arrays;
import java.util.List;
import java.util.PriorityQueue;
import java.util.Scanner;

public class ReadingBooks {
    /*
    оптимальная стратегия поведения девочек: одна начинает читать книги с 1-го конца списка, другая - с другого конца списка.
    Контрпример для выбора книг по минимальному значению: 2 8 3
    Контрпример для выбора книг для чтения по принципу самой долгочитаемой книги: 1 5 7 8
    Однако, есть очень важное наблюдение: если самая длинная книга читается дольше, чем все остальные книги вместе взятые, то
    время чтения будет равно удвоенному времени чтения последней книги (пример - 2 8 3), иначе существует способ расположить
    книги в таком порядке, что время чтения книг девочек будет равно сумме времени чтения каждой книги.

    Примитивное док-во:
    1-ый случай: если время чтения длиннейшей книги больше времени чтения всех остальных книг, то пусть тогда первый читатель
    читает книги 1, ..., n - 1, а второй начнет читать n-ую книгу. Тогда, первый будет ожидать второго и когда он закончит читать
    книгу, а после начнет читать n-ую книгу и будет читать ее столько же времени, сколько читал второй читатель. Тогда суммарное
    время чтения будет равно 2 * время чтения длиннейшей книги.
    2-ой случай: пусть первый читает книиги в порядке возрастания времени чтения, второй в порядке убывания. Тогда можно показать,
    что порядок чтения можно организовать таким образом что они не будут пересекаться при чтении вовсе.
    https://codeforces.com/blog/entry/79238?#comment-648392
     */
    //https://cses.fi/problemset/task/1631
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] timeOfReading = new int[n];
        for (int i = 0; i < n; i++) {
            timeOfReading[i] = scanner.nextInt();
        }

        Arrays.sort(timeOfReading);

        long sum = 0;
        for (int i = 0; i < n - 1; i++) {
            sum += timeOfReading[i];
        }

        if (sum < timeOfReading[n - 1]) {
            System.out.println(timeOfReading[n - 1] * 2);
        }
        else {
            System.out.println(sum + timeOfReading[n - 1]);
        }



    }
}
